From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: 404Setup <153366651+404Setup@users.noreply.github.com>
Date: Thu, 6 Jun 2024 12:20:34 +0800
Subject: [PATCH] Experimental: Show which zone has which players in tps
 command


diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java b/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
index ab5f832aafc479eca1c5da012e180d6374e32325..d55dfdb42d1153cb05ddaaa65dc6484d8f4d1fb2 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
@@ -4,6 +4,7 @@ import ca.spottedleaf.concurrentutil.scheduler.SchedulerThreadPool;
 import ca.spottedleaf.concurrentutil.util.TimeUtil;
 import com.mojang.logging.LogUtils;
 import io.papermc.paper.util.TickThread;
+import it.unimi.dsi.fastutil.objects.ObjectObjectImmutablePair;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.level.ChunkPos;
@@ -115,6 +116,19 @@ public final class TickRegionScheduler {
         return tickThreadRunner.currentTickingWorldRegionizedData;
     }
 
+    /**
+     * Returns the current ticking region and region's world regionised data, or {@code null} if there is no ticking region.
+     * This is a faster alternative to calling the {@link RegionizedData#get()} method.
+     * If this thread is not a TickThread, then returns {@code null}.
+     */
+    public static ObjectObjectImmutablePair<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>, RegionizedWorldData> getCurrentRegionPair() {
+        final Thread currThread = Thread.currentThread();
+        if (!(currThread instanceof TickThreadRunner tickThreadRunner)) {
+            return new ObjectObjectImmutablePair<>(RegionShutdownThread.getRegion(), RegionShutdownThread.getWorldData());
+        }
+        return new ObjectObjectImmutablePair<>(tickThreadRunner.currentTickingRegion, tickThreadRunner.currentTickingWorldRegionizedData);
+    }
+
     /**
      * Returns the current ticking task, or {@code null} if there is no ticking region.
      * If this thread is not a TickThread, then returns {@code null}.
@@ -314,9 +328,9 @@ public final class TickRegionScheduler {
 
             synchronized (this) {
                 this.currentTickData = new TickTime(
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET, tickStart, cpuStart,
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME,
-                    false
+                        SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET, tickStart, cpuStart,
+                        SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME,
+                        false
                 );
                 this.currentTickingThread = Thread.currentThread();
             }
@@ -338,8 +352,8 @@ public final class TickRegionScheduler {
                 final long cpuEnd = MEASURE_CPU_TIME ? THREAD_MX_BEAN.getCurrentThreadCpuTime() : 0L;
 
                 final TickTime time = new TickTime(
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET,
-                    tickStart, cpuStart, tickEnd, cpuEnd, MEASURE_CPU_TIME, false
+                        SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET,
+                        tickStart, cpuStart, tickEnd, cpuEnd, MEASURE_CPU_TIME, false
                 );
 
                 this.addTickTime(time);
@@ -392,9 +406,9 @@ public final class TickRegionScheduler {
             new me.earthme.luminol.api.events.TickRegionStartTickEvent(this.region == null ? -1 : this.region.region.id,System.nanoTime()); //Luminol - Threaded regions API
             synchronized (this) {
                 this.currentTickData = new TickTime(
-                    lastTickStart, scheduledStart, tickStart, cpuStart,
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME,
-                    true
+                        lastTickStart, scheduledStart, tickStart, cpuStart,
+                        SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME,
+                        true
                 );
                 this.currentTickingThread = Thread.currentThread();
             }
@@ -420,7 +434,7 @@ public final class TickRegionScheduler {
                 this.setScheduledStart(TimeUtil.getGreatestTime(tickEnd, this.tickSchedule.getDeadline(TIME_BETWEEN_TICKS)));
 
                 final TickTime time = new TickTime(
-                    lastTickStart, scheduledStart, tickStart, cpuStart, tickEnd, cpuEnd, MEASURE_CPU_TIME, true
+                        lastTickStart, scheduledStart, tickStart, cpuStart, tickEnd, cpuEnd, MEASURE_CPU_TIME, true
                 );
 
                 this.addTickTime(time);
@@ -459,10 +473,10 @@ public final class TickRegionScheduler {
             final long cpuEnd = MEASURE_CPU_TIME ? THREAD_MX_BEAN.getThreadCpuTime(this.currentTickingThread.getId()) : 0L;
 
             return new TickTime(
-                currentTickData.previousTickStart(), currentTickData.scheduledTickStart(),
-                currentTickData.tickStart(), currentTickData.tickStartCPU(),
-                tickEnd, cpuEnd,
-                MEASURE_CPU_TIME, currentTickData.isTickExecution()
+                    currentTickData.previousTickStart(), currentTickData.scheduledTickStart(),
+                    currentTickData.tickStart(), currentTickData.tickStartCPU(),
+                    tickEnd, cpuEnd,
+                    MEASURE_CPU_TIME, currentTickData.isTickExecution()
             );
         }
 
@@ -517,14 +531,14 @@ public final class TickRegionScheduler {
 
     // All time units are in nanoseconds.
     public static final record TickTime(
-        long previousTickStart,
-        long scheduledTickStart,
-        long tickStart,
-        long tickStartCPU,
-        long tickEnd,
-        long tickEndCPU,
-        boolean supportCPUTime,
-        boolean isTickExecution
+            long previousTickStart,
+            long scheduledTickStart,
+            long tickStart,
+            long tickStartCPU,
+            long tickEnd,
+            long tickEndCPU,
+            boolean supportCPUTime,
+            boolean isTickExecution
     ) {
         /**
          * The difference between the start tick time and the scheduled start tick time. This value is
diff --git a/src/main/java/io/papermc/paper/threadedregions/commands/CommandServerHealth.java b/src/main/java/io/papermc/paper/threadedregions/commands/CommandServerHealth.java
index b74ade39b4ac18af16a7a6340033e55f2cf2947a..2b7b0e8c835e94fa5be51ee6ba129de767d77a7a 100644
--- a/src/main/java/io/papermc/paper/threadedregions/commands/CommandServerHealth.java
+++ b/src/main/java/io/papermc/paper/threadedregions/commands/CommandServerHealth.java
@@ -15,6 +15,7 @@ import net.kyori.adventure.text.format.NamedTextColor;
 import net.kyori.adventure.text.format.TextColor;
 import net.kyori.adventure.text.format.TextDecoration;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.level.ChunkPos;
 import org.bukkit.Bukkit;
 import org.bukkit.World;
@@ -23,6 +24,7 @@ import org.bukkit.command.CommandSender;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.entity.Entity;
 import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
 
 import java.text.DecimalFormat;
 import java.util.ArrayList;
@@ -73,6 +75,34 @@ public final class CommandServerHealth extends Command {
                 .build();
     }
 
+    private static Component formatRegionStatsAsRegion(final TickRegions.RegionStats stats, final boolean newline) {
+        List<ServerPlayer> players = TickRegionScheduler.getCurrentRegionizedWorldData().getLocalPlayers();
+        final TextComponent builder = getTextComponent(players);
+        return Component.text()
+                .append(Component.text("Chunks: ", PRIMARY))
+                .append(Component.text(NO_DECIMAL_PLACES.get().format(stats.getChunkCount()), INFORMATION))
+                .append(Component.text(" Players: ", PRIMARY).hoverEvent(HoverEvent.showText(builder)))
+                .append(Component.text(NO_DECIMAL_PLACES.get().format(stats.getPlayerCount()), INFORMATION))
+                .append(Component.text(" Entities: ", PRIMARY))
+                .append(Component.text(NO_DECIMAL_PLACES.get().format(stats.getEntityCount()) + (newline ? "\n" : ""), INFORMATION))
+                .build();
+    }
+
+    private static @NotNull TextComponent getTextComponent(List<ServerPlayer> players) {
+        @NotNull TextComponent builder = Component.text("Region Player List: ");
+        for (final ServerPlayer player : players) {
+            builder = builder.append(Component.text("\n")).
+                    append(Component.text(player.gameProfile.getName()))
+                    .append(Component.text(" | In "))
+                    .append(Component.text(player.getOnPos().getX()))
+                    .append(Component.text(", "))
+                    .append(Component.text(player.getOnPos().getY()))
+                    .append(Component.text(", "))
+                    .append(Component.text(player.getOnPos().getZ()));
+        }
+        return builder;
+    }
+
     private static boolean executeRegion(final CommandSender sender, final String commandLabel, final String[] args) {
         final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
                 TickRegionScheduler.getCurrentRegion();
@@ -114,7 +144,7 @@ public final class CommandServerHealth extends Command {
                         formatRegionInfo("1m: ", util1m, mspt1m, tps1m, true)
                 )
                 .append(
-                        formatRegionStats(region.getData().getRegionStats(), false)
+                        formatRegionStatsAsRegion(region.getData().getRegionStats(), false)
                 )
 
                 .build();
