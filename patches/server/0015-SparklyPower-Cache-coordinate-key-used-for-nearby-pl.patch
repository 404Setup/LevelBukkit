From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: 404Setup <153366651+404Setup@users.noreply.github.com>
Date: Thu, 30 May 2024 12:57:53 +0800
Subject: [PATCH] SparklyPower: Cache coordinate key used for nearby players
 when ticking chunks

The "getChunkKey(...)" call is a bit expensive, using 0.24% of CPU time with 19k chunks loaded

So instead of paying the price on each tick, we pay the price when the chunk is loaded

Which, if you think about it, is actually better, since we tick chunks more than we load chunks

diff --git a/src/main/java/io/papermc/paper/util/player/NearbyPlayers.java b/src/main/java/io/papermc/paper/util/player/NearbyPlayers.java
index f164256d59b761264876ca0c85f812d101bfd5de..660c4e1082d8f7e48d5c34b7594ab0b3dbdf435b 100644
--- a/src/main/java/io/papermc/paper/util/player/NearbyPlayers.java
+++ b/src/main/java/io/papermc/paper/util/player/NearbyPlayers.java
@@ -106,6 +106,13 @@ public final class NearbyPlayers {
         return chunk == null ? null : chunk.players[type.ordinal()];
     }
 
+    // SparklyPaper start - cache coordinate key used for nearby players
+    public ReferenceList<ServerPlayer> getPlayers(final long nearbyPlayersCoordinateKey, final NearbyMapType type) {
+        final TrackedChunk chunk = this.byChunk.get(nearbyPlayersCoordinateKey);
+        return chunk == null ? null : chunk.players[type.ordinal()];
+    }
+    // SparklyPaper end
+
     public ReferenceList<ServerPlayer> getPlayersByChunk(final int chunkX, final int chunkZ, final NearbyMapType type) {
         final TrackedChunk chunk = this.byChunk.get(CoordinateUtils.getChunkKey(chunkX, chunkZ));
 
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 74483543836d9ed042cc7b9cbbde8d58d6994475..4d199839b6a2551783a8ed98ce181cc92e56d0a7 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -10,7 +10,6 @@ import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
-import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
@@ -200,9 +199,7 @@ public class ServerChunkCache extends ChunkSource {
     public ChunkAccess getChunk(int x, int z, ChunkStatus leastStatus, boolean create) {
         final int x1 = x; final int z1 = z; // Paper - conflict on variable change
         if (!io.papermc.paper.util.TickThread.isTickThread()) { // Paper - rewrite chunk system
-            return (ChunkAccess) CompletableFuture.supplyAsync(() -> {
-                return this.getChunk(x, z, leastStatus, create);
-            }, this.mainThreadProcessor).join();
+            return CompletableFuture.supplyAsync(() -> this.getChunk(x, z, leastStatus, create), this.mainThreadProcessor).join();
         } else {
             // Paper start - Perf: Optimise getChunkAt calls for loaded chunks
             LevelChunk ifLoaded = this.getChunkAtIfLoadedMainThread(x, z);
@@ -232,9 +229,7 @@ public class ServerChunkCache extends ChunkSource {
                 io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.popChunkWait(); // Paper - rewrite chunk system
                 this.level.timings.syncChunkLoad.stopTiming(); // Paper
             } // Paper
-            ichunkaccess = (ChunkAccess) ((Either) completablefuture.join()).map((ichunkaccess1) -> {
-                return ichunkaccess1;
-            }, (playerchunk_failure) -> {
+            ichunkaccess = (ChunkAccess) ((Either) completablefuture.join()).map((ichunkaccess1) -> ichunkaccess1, (playerchunk_failure) -> {
                 if (create) {
                     throw (IllegalStateException) Util.pauseInIde(new IllegalStateException("Chunk not there when requested: " + playerchunk_failure));
                 } else {
@@ -274,11 +269,7 @@ public class ServerChunkCache extends ChunkSource {
             Objects.requireNonNull(completablefuture);
             chunkproviderserver_b.managedBlock(completablefuture::isDone);
         } else {
-            completablefuture = CompletableFuture.supplyAsync(() -> {
-                return this.getChunkFutureMainThread(chunkX, chunkZ, leastStatus, create);
-            }, this.mainThreadProcessor).thenCompose((completablefuture1) -> {
-                return completablefuture1;
-            });
+            completablefuture = CompletableFuture.supplyAsync(() -> this.getChunkFutureMainThread(chunkX, chunkZ, leastStatus, create), this.mainThreadProcessor).thenCompose((completablefuture1) -> completablefuture1);
         }
 
         return completablefuture;
@@ -520,9 +511,9 @@ public class ServerChunkCache extends ChunkSource {
                     int viewDistance = io.papermc.paper.chunk.system.ChunkSystem.getTickViewDistance(player);
 
                     // copied and modified from isOutisdeRange
-                    int chunkRange = (int)level.spigotConfig.mobSpawnRange;
-                    chunkRange = (chunkRange > viewDistance) ? viewDistance : chunkRange;
-                    chunkRange = (chunkRange > DistanceManager.MOB_SPAWN_RANGE) ? DistanceManager.MOB_SPAWN_RANGE : chunkRange;
+                    int chunkRange = level.spigotConfig.mobSpawnRange;
+                    chunkRange = Math.min(chunkRange, viewDistance);
+                    chunkRange = Math.min(chunkRange, DistanceManager.MOB_SPAWN_RANGE);
 
                     com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event = new com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent(player.getBukkitEntity(), (byte)chunkRange);
                     event.callEvent();
@@ -538,7 +529,7 @@ public class ServerChunkCache extends ChunkSource {
                     int chunkZ = io.papermc.paper.util.CoordinateUtils.getChunkCoordinate(player.getZ());
 
                     regionizedWorldData.mobSpawnMap.addOrUpdate(player, chunkX, chunkZ, range); // Folia - region threading
-                    player.lastEntitySpawnRadiusSquared = (double)((range << 4) * (range << 4)); // used in anyPlayerCloseEnoughForSpawning
+                    player.lastEntitySpawnRadiusSquared = (range << 4) * (range << 4); // used in anyPlayerCloseEnoughForSpawning
                     player.playerNaturallySpawnedEvent = event;
                 }
                 // Paper end - optimise chunk tick iteration
@@ -573,7 +564,7 @@ public class ServerChunkCache extends ChunkSource {
 
                     // Paper start - optimise chunk tick iteration
                     com.destroystokyo.paper.util.maplist.ReferenceList<ServerPlayer> playersNearby
-                        = nearbyPlayers.getPlayers(chunkcoordintpair, io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.SPAWN_RANGE);
+                            = nearbyPlayers.getPlayers(chunk1.nearbyPlayersCoordinateKey, io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.SPAWN_RANGE); // nearbyPlayers.getPlayers(chunkcoordintpair, io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.SPAWN_RANGE); // SparklyPaper - cache coordinate key used for nearby players
                     if (playersNearby == null) {
                         continue;
                     }
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
index f7e5e016a7028a9196e689e950805b0d5b31fe38..d0285843920f78e05ce07b1b0b2d8ce97ec8041e 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -62,7 +62,7 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
     protected final ShortList[] postProcessing;
     protected volatile boolean unsaved;
     private volatile boolean isLightCorrect;
-    protected final ChunkPos chunkPos; public final long coordinateKey; public final int locX; public final int locZ; // Paper - cache coordinate key
+    protected final ChunkPos chunkPos; public final long coordinateKey; public final long nearbyPlayersCoordinateKey; public final int locX; public final int locZ; // Paper - cache coordinate key // SparklyPaper - cache coordinate key used for nearby players
     private long inhabitedTime;
     /** @deprecated */
     @Nullable
@@ -136,7 +136,7 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
         }
         // Paper end - rewrite light engine
         this.locX = pos.x; this.locZ = pos.z; // Paper - reduce need for field lookups
-        this.chunkPos = pos; this.coordinateKey = ChunkPos.asLong(locX, locZ); // Paper - cache long key
+        this.chunkPos = pos; this.coordinateKey = ChunkPos.asLong(locX, locZ); this.nearbyPlayersCoordinateKey = io.papermc.paper.util.CoordinateUtils.getChunkKey(locX, locZ); // Paper - cache long key // SparklyPaper - cache coordinate key used for nearby players
         this.upgradeData = upgradeData;
         this.levelHeightAccessor = heightLimitView;
         this.sections = new LevelChunkSection[heightLimitView.getSectionsCount()];
