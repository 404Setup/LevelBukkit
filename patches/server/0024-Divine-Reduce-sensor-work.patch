From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: 404Setup <153366651+404Setup@users.noreply.github.com>
Date: Fri, 31 May 2024 19:44:00 +0800
Subject: [PATCH] Divine: Reduce sensor work

Original project: Bloom-host/Petal
Link: https://github.com/Bloom-host/Petal

diff --git a/src/main/java/dev/paged/lb/Config/LevelBukkitConfig.java b/src/main/java/dev/paged/lb/Config/LevelBukkitConfig.java
index 5747b65d9107c0acd0bf0c6c90f19ec74fad9a20..2d292a9adcec37c49041b3b7cd6647097324165c 100644
--- a/src/main/java/dev/paged/lb/Config/LevelBukkitConfig.java
+++ b/src/main/java/dev/paged/lb/Config/LevelBukkitConfig.java
@@ -18,6 +18,16 @@ public class LevelBukkitConfig {
         public static boolean recipeManagerOptimization = true;
     }
 
+    public static class purpur {
+        public static class world {
+                public static boolean sensorOptimization = true;
+                public static double skeletonHeadVisibilityPercent = 0;
+                public static double zombieHeadVisibilityPercent = 0.5D;
+                public static double creeperHeadVisibilityPercent = 0.5D;
+                public static double piglinHeadVisibilityPercent = 0.5D;
+        }
+    }
+
     public static void load() {
         try {
             File configFile = new File("levelbukkit.yml");
@@ -27,11 +37,21 @@ public class LevelBukkitConfig {
             YamlConfiguration configuration = YamlConfiguration.loadConfiguration(configFile);
             configuration.addDefault("foldenor.enableSecureSeed", false);
             configuration.addDefault("divine.recipeManagerOptimization", true);
+            configuration.addDefault("purpur.world.sensorOptimization", true);
+            configuration.addDefault("purpur.world.skeletonHeadVisibilityPercent", 0.5D);
+            configuration.addDefault("purpur.world.zombieHeadVisibilityPercent", 0.5D);
+            configuration.addDefault("purpur.world.creeperHeadVisibilityPercent", 0.5D);
+            configuration.addDefault("purpur.world.piglinHeadVisibilityPercent", 0.5D);
             configuration.options().copyDefaults(true);
             configuration.save(configFile);
 
             foldenor.enableSecureSeed = configuration.getBoolean("foldenor.enableSecureSeed");
             divine.recipeManagerOptimization = configuration.getBoolean("divine.recipeManagerOptimization");
+            purpur.world.sensorOptimization = configuration.getBoolean("purpur.world.sensorOptimization");
+            purpur.world.skeletonHeadVisibilityPercent = configuration.getDouble("purpur.world.skeletonHeadVisibilityPercent");
+            purpur.world.zombieHeadVisibilityPercent = configuration.getDouble("purpur.world.zombieHeadVisibilityPercent");
+            purpur.world.creeperHeadVisibilityPercent = configuration.getDouble("purpur.world.creeperHeadVisibilityPercent");
+            purpur.world.piglinHeadVisibilityPercent = configuration.getDouble("purpur.world.piglinHeadVisibilityPercent");
 
             // Pufferfish start
             // Attempt to detect vectorization
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index a39c9596e8247b38c2dba7b9c8b3c98178e57a32..16d060c1ec00b1453d3ba27181a1d7b341244da9 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -18,6 +18,8 @@ import java.util.Optional;
 import java.util.UUID;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+
+import dev.paged.lb.Config.LevelBukkitConfig;
 import net.minecraft.BlockUtil;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.commands.arguments.EntityAnchorArgument;
@@ -797,11 +799,8 @@ public abstract class LivingEntity extends Entity implements Attackable {
         nbt.put("Attributes", this.getAttributes().save());
         if (!this.activeEffects.isEmpty()) {
             ListTag nbttaglist = new ListTag();
-            Iterator iterator = this.activeEffects.values().iterator();
-
-            while (iterator.hasNext()) {
-                MobEffectInstance mobeffect = (MobEffectInstance) iterator.next();
 
+            for (MobEffectInstance mobeffect : this.activeEffects.values()) {
                 nbttaglist.add(mobeffect.save(new CompoundTag()));
             }
 
@@ -1049,11 +1048,32 @@ public abstract class LivingEntity extends Entity implements Attackable {
         }
 
         if (entity != null) {
-            ItemStack itemstack = this.getItemBySlot(EquipmentSlot.HEAD);
-            EntityType<?> entitytypes = entity.getType();
 
-            if (entitytypes == EntityType.SKELETON && itemstack.is(Items.SKELETON_SKULL) || entitytypes == EntityType.ZOMBIE && itemstack.is(Items.ZOMBIE_HEAD) || entitytypes == EntityType.PIGLIN && itemstack.is(Items.PIGLIN_HEAD) || entitytypes == EntityType.PIGLIN_BRUTE && itemstack.is(Items.PIGLIN_HEAD) || entitytypes == EntityType.CREEPER && itemstack.is(Items.CREEPER_HEAD)) {
-                d0 *= 0.5D;
+            EntityType<?> entitytypes = entity.getType();
+            if (LevelBukkitConfig.purpur.world.sensorOptimization) {
+                // Purpur start
+                if (entitytypes == EntityType.SKELETON && this.getItemBySlot(EquipmentSlot.HEAD).is(Items.SKELETON_SKULL)) { // DivineMC - Reduce sensor work
+                    d0 *= LevelBukkitConfig.purpur.world.skeletonHeadVisibilityPercent;
+                }
+                else if (entitytypes == EntityType.ZOMBIE && this.getItemBySlot(EquipmentSlot.HEAD).is(Items.ZOMBIE_HEAD)) { // DivineMC - Reduce sensor work
+                    d0 *= LevelBukkitConfig.purpur.world.zombieHeadVisibilityPercent;
+                }
+                else if (entitytypes == EntityType.CREEPER && this.getItemBySlot(EquipmentSlot.HEAD).is(Items.CREEPER_HEAD)) { // DivineMC - Reduce sensor work
+                    d0 *= LevelBukkitConfig.purpur.world.creeperHeadVisibilityPercent;
+                }
+                else if ((entitytypes == EntityType.PIGLIN || entitytypes == EntityType.PIGLIN_BRUTE) && this.getItemBySlot(EquipmentSlot.HEAD).is(Items.PIGLIN_HEAD)) { // DivineMC - Reduce sensor work
+                    d0 *= LevelBukkitConfig.purpur.world.piglinHeadVisibilityPercent;
+                }
+                // Purpur end
+            } else {
+                ItemStack itemstack = this.getItemBySlot(EquipmentSlot.HEAD);
+                if (entitytypes == EntityType.SKELETON && itemstack.is(Items.SKELETON_SKULL)
+                        || entitytypes == EntityType.ZOMBIE && itemstack.is(Items.ZOMBIE_HEAD)
+                        || entitytypes == EntityType.PIGLIN && itemstack.is(Items.PIGLIN_HEAD)
+                        || entitytypes == EntityType.PIGLIN_BRUTE && itemstack.is(Items.PIGLIN_HEAD)
+                        || entitytypes == EntityType.CREEPER && itemstack.is(Items.CREEPER_HEAD)) {
+                    d0 *= 0.5D;
+                }
             }
         }
 
@@ -1290,14 +1310,9 @@ public abstract class LivingEntity extends Entity implements Attackable {
     }
 
     public void sendEffectToPassengers(MobEffectInstance effect) {
-        Iterator iterator = this.getPassengers().iterator();
-
-        while (iterator.hasNext()) {
-            Entity entity = (Entity) iterator.next();
-
-            if (entity instanceof ServerPlayer) {
-                ServerPlayer entityplayer = (ServerPlayer) entity;
 
+        for (Entity entity : this.getPassengers()) {
+            if (entity instanceof ServerPlayer entityplayer) {
                 entityplayer.connection.send(new ClientboundUpdateMobEffectPacket(this.getId(), effect));
             }
         }
@@ -1325,14 +1340,9 @@ public abstract class LivingEntity extends Entity implements Attackable {
         if (!this.level().isClientSide) {
             effect.getEffect().removeAttributeModifiers(this.getAttributes());
             this.refreshDirtyAttributes();
-            Iterator iterator = this.getPassengers().iterator();
-
-            while (iterator.hasNext()) {
-                Entity entity = (Entity) iterator.next();
-
-                if (entity instanceof ServerPlayer) {
-                    ServerPlayer entityplayer = (ServerPlayer) entity;
 
+            for (Entity entity : this.getPassengers()) {
+                if (entity instanceof ServerPlayer entityplayer) {
                     entityplayer.connection.send(new ClientboundRemoveMobEffectPacket(this.getId(), effect.getEffect()));
                 }
             }
@@ -1341,11 +1351,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
     }
 
     private void refreshDirtyAttributes() {
-        Iterator iterator = this.getAttributes().getDirtyAttributes().iterator();
-
-        while (iterator.hasNext()) {
-            AttributeInstance attributemodifiable = (AttributeInstance) iterator.next();
-
+        for (AttributeInstance attributemodifiable : this.getAttributes().getDirtyAttributes()) {
             this.onAttributeUpdated(attributemodifiable.getAttribute());
         }
 
@@ -1526,30 +1532,22 @@ public abstract class LivingEntity extends Entity implements Attackable {
             Entity entity1 = source.getEntity();
 
             if (entity1 != null) {
-                if (entity1 instanceof LivingEntity) {
-                    LivingEntity entityliving1 = (LivingEntity) entity1;
-
+                if (entity1 instanceof LivingEntity entityliving1) {
                     if (!source.is(DamageTypeTags.NO_ANGER)) {
                         this.setLastHurtByMob(entityliving1);
                     }
                 }
 
-                if (entity1 instanceof net.minecraft.world.entity.player.Player) {
-                    net.minecraft.world.entity.player.Player entityhuman = (net.minecraft.world.entity.player.Player) entity1;
-
+                if (entity1 instanceof net.minecraft.world.entity.player.Player entityhuman) {
                     this.lastHurtByPlayerTime = 100;
                     this.lastHurtByPlayer = entityhuman;
-                } else if (entity1 instanceof Wolf) {
-                    Wolf entitywolf = (Wolf) entity1;
-
+                } else if (entity1 instanceof Wolf entitywolf) {
                     if (entitywolf.isTame()) {
                         this.lastHurtByPlayerTime = 100;
                         LivingEntity entityliving2 = entitywolf.getOwner();
 
                         if (entityliving2 instanceof net.minecraft.world.entity.player.Player) {
-                            net.minecraft.world.entity.player.Player entityhuman1 = (net.minecraft.world.entity.player.Player) entityliving2;
-
-                            this.lastHurtByPlayer = entityhuman1;
+                            this.lastHurtByPlayer = (net.minecraft.world.entity.player.Player) entityliving2;
                         } else {
                             this.lastHurtByPlayer = null;
                         }
@@ -1639,8 +1637,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
             // CraftBukkit start
             InteractionHand hand = null;
             ItemStack itemstack1 = ItemStack.EMPTY;
-            for (int j = 0; j < i; ++j) {
-                InteractionHand enumhand = aenumhand[j];
+            for (InteractionHand enumhand : aenumhand) {
                 itemstack1 = this.getItemInHand(enumhand);
 
                 if (itemstack1.is(Items.TOTEM_OF_UNDYING)) {
@@ -1660,10 +1657,8 @@ public abstract class LivingEntity extends Entity implements Attackable {
                 if (!itemstack1.isEmpty() && itemstack != null) { // Paper - only reduce item if actual totem was found
                     itemstack1.shrink(1);
                 }
-                if (itemstack != null && this instanceof ServerPlayer) {
+                if (itemstack != null && this instanceof ServerPlayer entityplayer) {
                     // CraftBukkit end
-                    ServerPlayer entityplayer = (ServerPlayer) this;
-
                     entityplayer.awardStat(Stats.ITEM_USED.get(Items.TOTEM_OF_UNDYING));
                     CriteriaTriggers.USED_TOTEM.trigger(entityplayer, itemstack);
                     this.gameEvent(GameEvent.ITEM_INTERACT_FINISH);
@@ -1705,9 +1700,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
         Entity entity = source.getDirectEntity();
         boolean flag = false;
 
-        if (entity instanceof AbstractArrow) {
-            AbstractArrow entityarrow = (AbstractArrow) entity;
-
+        if (entity instanceof AbstractArrow entityarrow) {
             if (entityarrow.getPierceLevel() > 0) {
                 flag = true;
             }
@@ -2310,8 +2303,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
             EntityDamageEvent event = CraftEventFactory.handleLivingEntityDamageEvent(this, damagesource, originalDamage, hardHatModifier, blockingModifier, armorModifier, resistanceModifier, magicModifier, absorptionModifier, hardHat, blocking, armor, resistance, magic, absorption);
             if (damagesource.getEntity() instanceof net.minecraft.world.entity.player.Player) {
                 // Paper start - PlayerAttackEntityCooldownResetEvent
-                if (damagesource.getEntity() instanceof ServerPlayer) {
-                    ServerPlayer player = (ServerPlayer) damagesource.getEntity();
+                if (damagesource.getEntity() instanceof ServerPlayer player) {
                     if (new com.destroystokyo.paper.event.player.PlayerAttackEntityCooldownResetEvent(player.getBukkitEntity(), this.getBukkitEntity(), player.getAttackStrengthScale(0F)).callEvent()) {
                         player.resetAttackStrengthTicker();
                     }
@@ -2370,9 +2362,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
             if (f2 > 0.0F && f2 < 3.4028235E37F) {
                 Entity entity = damagesource.getEntity();
 
-                if (entity instanceof ServerPlayer) {
-                    ServerPlayer entityplayer = (ServerPlayer) entity;
-
+                if (entity instanceof ServerPlayer entityplayer) {
                     entityplayer.awardStat(Stats.DAMAGE_DEALT_ABSORBED, Math.round(f2 * 10.0F));
                 }
             }
@@ -3217,10 +3207,8 @@ public abstract class LivingEntity extends Entity implements Attackable {
     private Map<EquipmentSlot, ItemStack> collectEquipmentChanges() {
         Map<EquipmentSlot, ItemStack> map = null;
         EquipmentSlot[] aenumitemslot = EquipmentSlot.values();
-        int i = aenumitemslot.length;
 
-        for (int j = 0; j < i; ++j) {
-            EquipmentSlot enumitemslot = aenumitemslot[j];
+        for (EquipmentSlot enumitemslot : aenumitemslot) {
             ItemStack itemstack;
 
             switch (enumitemslot.getType()) {
@@ -3536,9 +3524,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
         {
             LivingEntity entityliving = this.getControllingPassenger();
 
-            if (entityliving instanceof net.minecraft.world.entity.player.Player) {
-                net.minecraft.world.entity.player.Player entityhuman = (net.minecraft.world.entity.player.Player) entityliving;
-
+            if (entityliving instanceof net.minecraft.world.entity.player.Player entityhuman) {
                 if (this.isAlive()) {
                     this.travelRidden(entityhuman, vec3d1);
                     break label104;
@@ -3662,11 +3648,8 @@ public abstract class LivingEntity extends Entity implements Attackable {
 
                 if (i > 0 && list.size() > i - 1 && this.random.nextInt(4) == 0) {
                     int j = 0;
-                    Iterator iterator = list.iterator();
-
-                    while (iterator.hasNext()) {
-                        Entity entity = (Entity) iterator.next();
 
+                    for (Entity entity : list) {
                         if (!entity.isPassenger()) {
                             ++j;
                         }
@@ -3696,11 +3679,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
         List<Entity> list = this.level().getEntities(this, axisalignedbb2);
 
         if (!list.isEmpty()) {
-            Iterator iterator = list.iterator();
-
-            while (iterator.hasNext()) {
-                Entity entity = (Entity) iterator.next();
-
+            for (Entity entity : list) {
                 if (entity instanceof LivingEntity) {
                     this.doAutoAttackOnTouch((LivingEntity) entity);
                     this.autoSpinAttackTicks = 0;
@@ -4502,13 +4481,10 @@ public abstract class LivingEntity extends Entity implements Attackable {
 
         if (item.isEdible()) {
             List<Pair<MobEffectInstance, Float>> list = item.getFoodProperties().getEffects();
-            Iterator iterator = list.iterator();
 
-            while (iterator.hasNext()) {
-                Pair<MobEffectInstance, Float> pair = (Pair) iterator.next();
-
-                if (!world.isClientSide && pair.getFirst() != null && world.random.nextFloat() < (Float) pair.getSecond()) {
-                    targetEntity.addEffect(new MobEffectInstance((MobEffectInstance) pair.getFirst()), EntityPotionEffectEvent.Cause.FOOD); // CraftBukkit
+            for (Pair<MobEffectInstance, Float> mobEffectInstanceFloatPair : list) {
+                if (!world.isClientSide && mobEffectInstanceFloatPair.getFirst() != null && world.random.nextFloat() < (Float) mobEffectInstanceFloatPair.getSecond()) {
+                    targetEntity.addEffect(new MobEffectInstance(mobEffectInstanceFloatPair.getFirst()), EntityPotionEffectEvent.Cause.FOOD); // CraftBukkit
                 }
             }
         }
@@ -4516,22 +4492,15 @@ public abstract class LivingEntity extends Entity implements Attackable {
     }
 
     public static byte entityEventForEquipmentBreak(EquipmentSlot slot) {
-        switch (slot) {
-            case MAINHAND:
-                return 47;
-            case OFFHAND:
-                return 48;
-            case HEAD:
-                return 49;
-            case CHEST:
-                return 50;
-            case FEET:
-                return 52;
-            case LEGS:
-                return 51;
-            default:
-                return 47;
-        }
+        return switch (slot) {
+            case MAINHAND -> 47;
+            case OFFHAND -> 48;
+            case HEAD -> 49;
+            case CHEST -> 50;
+            case FEET -> 52;
+            case LEGS -> 51;
+            default -> 47;
+        };
     }
 
     public void broadcastBreakEvent(EquipmentSlot slot) {
